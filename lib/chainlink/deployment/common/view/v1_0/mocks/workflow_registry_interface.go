// Code generated by mockery v2.53.0. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	common "github.com/ethereum/go-ethereum/common"

	event "github.com/ethereum/go-ethereum/event"

	generated "github.com/smartcontractkit/chainlink/v2/core/gethwrappers/generated"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"

	workflow_registry_wrapper "github.com/smartcontractkit/chainlink/v2/core/gethwrappers/workflow/generated/workflow_registry_wrapper"
)

// WorkflowRegistryInterface is an autogenerated mock type for the WorkflowRegistryInterface type
type WorkflowRegistryInterface struct {
	mock.Mock
}

type WorkflowRegistryInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *WorkflowRegistryInterface) EXPECT() *WorkflowRegistryInterface_Expecter {
	return &WorkflowRegistryInterface_Expecter{mock: &_m.Mock}
}

// AcceptOwnership provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) AcceptOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for AcceptOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_AcceptOwnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcceptOwnership'
type WorkflowRegistryInterface_AcceptOwnership_Call struct {
	*mock.Call
}

// AcceptOwnership is a helper method to define mock.On call
//   - opts *bind.TransactOpts
func (_e *WorkflowRegistryInterface_Expecter) AcceptOwnership(opts interface{}) *WorkflowRegistryInterface_AcceptOwnership_Call {
	return &WorkflowRegistryInterface_AcceptOwnership_Call{Call: _e.mock.On("AcceptOwnership", opts)}
}

func (_c *WorkflowRegistryInterface_AcceptOwnership_Call) Run(run func(opts *bind.TransactOpts)) *WorkflowRegistryInterface_AcceptOwnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_AcceptOwnership_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_AcceptOwnership_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_AcceptOwnership_Call) RunAndReturn(run func(*bind.TransactOpts) (*types.Transaction, error)) *WorkflowRegistryInterface_AcceptOwnership_Call {
	_c.Call.Return(run)
	return _c
}

// ActivateWorkflow provides a mock function with given fields: opts, workflowKey
func (_m *WorkflowRegistryInterface) ActivateWorkflow(opts *bind.TransactOpts, workflowKey [32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, workflowKey)

	if len(ret) == 0 {
		panic("no return value specified for ActivateWorkflow")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte) (*types.Transaction, error)); ok {
		return rf(opts, workflowKey)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte) *types.Transaction); ok {
		r0 = rf(opts, workflowKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte) error); ok {
		r1 = rf(opts, workflowKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ActivateWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ActivateWorkflow'
type WorkflowRegistryInterface_ActivateWorkflow_Call struct {
	*mock.Call
}

// ActivateWorkflow is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - workflowKey [32]byte
func (_e *WorkflowRegistryInterface_Expecter) ActivateWorkflow(opts interface{}, workflowKey interface{}) *WorkflowRegistryInterface_ActivateWorkflow_Call {
	return &WorkflowRegistryInterface_ActivateWorkflow_Call{Call: _e.mock.On("ActivateWorkflow", opts, workflowKey)}
}

func (_c *WorkflowRegistryInterface_ActivateWorkflow_Call) Run(run func(opts *bind.TransactOpts, workflowKey [32]byte)) *WorkflowRegistryInterface_ActivateWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ActivateWorkflow_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_ActivateWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ActivateWorkflow_Call) RunAndReturn(run func(*bind.TransactOpts, [32]byte) (*types.Transaction, error)) *WorkflowRegistryInterface_ActivateWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// Address provides a mock function with no fields
func (_m *WorkflowRegistryInterface) Address() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Address")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// WorkflowRegistryInterface_Address_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Address'
type WorkflowRegistryInterface_Address_Call struct {
	*mock.Call
}

// Address is a helper method to define mock.On call
func (_e *WorkflowRegistryInterface_Expecter) Address() *WorkflowRegistryInterface_Address_Call {
	return &WorkflowRegistryInterface_Address_Call{Call: _e.mock.On("Address")}
}

func (_c *WorkflowRegistryInterface_Address_Call) Run(run func()) *WorkflowRegistryInterface_Address_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *WorkflowRegistryInterface_Address_Call) Return(_a0 common.Address) *WorkflowRegistryInterface_Address_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *WorkflowRegistryInterface_Address_Call) RunAndReturn(run func() common.Address) *WorkflowRegistryInterface_Address_Call {
	_c.Call.Return(run)
	return _c
}

// ComputeHashKey provides a mock function with given fields: opts, owner, field
func (_m *WorkflowRegistryInterface) ComputeHashKey(opts *bind.CallOpts, owner common.Address, field string) ([32]byte, error) {
	ret := _m.Called(opts, owner, field)

	if len(ret) == 0 {
		panic("no return value specified for ComputeHashKey")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address, string) ([32]byte, error)); ok {
		return rf(opts, owner, field)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address, string) [32]byte); ok {
		r0 = rf(opts, owner, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address, string) error); ok {
		r1 = rf(opts, owner, field)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ComputeHashKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ComputeHashKey'
type WorkflowRegistryInterface_ComputeHashKey_Call struct {
	*mock.Call
}

// ComputeHashKey is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - owner common.Address
//   - field string
func (_e *WorkflowRegistryInterface_Expecter) ComputeHashKey(opts interface{}, owner interface{}, field interface{}) *WorkflowRegistryInterface_ComputeHashKey_Call {
	return &WorkflowRegistryInterface_ComputeHashKey_Call{Call: _e.mock.On("ComputeHashKey", opts, owner, field)}
}

func (_c *WorkflowRegistryInterface_ComputeHashKey_Call) Run(run func(opts *bind.CallOpts, owner common.Address, field string)) *WorkflowRegistryInterface_ComputeHashKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(common.Address), args[2].(string))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ComputeHashKey_Call) Return(_a0 [32]byte, _a1 error) *WorkflowRegistryInterface_ComputeHashKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ComputeHashKey_Call) RunAndReturn(run func(*bind.CallOpts, common.Address, string) ([32]byte, error)) *WorkflowRegistryInterface_ComputeHashKey_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWorkflow provides a mock function with given fields: opts, workflowKey
func (_m *WorkflowRegistryInterface) DeleteWorkflow(opts *bind.TransactOpts, workflowKey [32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, workflowKey)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflow")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte) (*types.Transaction, error)); ok {
		return rf(opts, workflowKey)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte) *types.Transaction); ok {
		r0 = rf(opts, workflowKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte) error); ok {
		r1 = rf(opts, workflowKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_DeleteWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWorkflow'
type WorkflowRegistryInterface_DeleteWorkflow_Call struct {
	*mock.Call
}

// DeleteWorkflow is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - workflowKey [32]byte
func (_e *WorkflowRegistryInterface_Expecter) DeleteWorkflow(opts interface{}, workflowKey interface{}) *WorkflowRegistryInterface_DeleteWorkflow_Call {
	return &WorkflowRegistryInterface_DeleteWorkflow_Call{Call: _e.mock.On("DeleteWorkflow", opts, workflowKey)}
}

func (_c *WorkflowRegistryInterface_DeleteWorkflow_Call) Run(run func(opts *bind.TransactOpts, workflowKey [32]byte)) *WorkflowRegistryInterface_DeleteWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_DeleteWorkflow_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_DeleteWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_DeleteWorkflow_Call) RunAndReturn(run func(*bind.TransactOpts, [32]byte) (*types.Transaction, error)) *WorkflowRegistryInterface_DeleteWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// FilterAllowedDONsUpdatedV1 provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) FilterAllowedDONsUpdatedV1(opts *bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1Iterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterAllowedDONsUpdatedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1Iterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1Iterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1Iterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1Iterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterAllowedDONsUpdatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterAllowedDONsUpdatedV1'
type WorkflowRegistryInterface_FilterAllowedDONsUpdatedV1_Call struct {
	*mock.Call
}

// FilterAllowedDONsUpdatedV1 is a helper method to define mock.On call
//   - opts *bind.FilterOpts
func (_e *WorkflowRegistryInterface_Expecter) FilterAllowedDONsUpdatedV1(opts interface{}) *WorkflowRegistryInterface_FilterAllowedDONsUpdatedV1_Call {
	return &WorkflowRegistryInterface_FilterAllowedDONsUpdatedV1_Call{Call: _e.mock.On("FilterAllowedDONsUpdatedV1", opts)}
}

func (_c *WorkflowRegistryInterface_FilterAllowedDONsUpdatedV1_Call) Run(run func(opts *bind.FilterOpts)) *WorkflowRegistryInterface_FilterAllowedDONsUpdatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterAllowedDONsUpdatedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1Iterator, _a1 error) *WorkflowRegistryInterface_FilterAllowedDONsUpdatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterAllowedDONsUpdatedV1_Call) RunAndReturn(run func(*bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1Iterator, error)) *WorkflowRegistryInterface_FilterAllowedDONsUpdatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// FilterAuthorizedAddressesUpdatedV1 provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) FilterAuthorizedAddressesUpdatedV1(opts *bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1Iterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterAuthorizedAddressesUpdatedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1Iterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1Iterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1Iterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1Iterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterAuthorizedAddressesUpdatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterAuthorizedAddressesUpdatedV1'
type WorkflowRegistryInterface_FilterAuthorizedAddressesUpdatedV1_Call struct {
	*mock.Call
}

// FilterAuthorizedAddressesUpdatedV1 is a helper method to define mock.On call
//   - opts *bind.FilterOpts
func (_e *WorkflowRegistryInterface_Expecter) FilterAuthorizedAddressesUpdatedV1(opts interface{}) *WorkflowRegistryInterface_FilterAuthorizedAddressesUpdatedV1_Call {
	return &WorkflowRegistryInterface_FilterAuthorizedAddressesUpdatedV1_Call{Call: _e.mock.On("FilterAuthorizedAddressesUpdatedV1", opts)}
}

func (_c *WorkflowRegistryInterface_FilterAuthorizedAddressesUpdatedV1_Call) Run(run func(opts *bind.FilterOpts)) *WorkflowRegistryInterface_FilterAuthorizedAddressesUpdatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterAuthorizedAddressesUpdatedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1Iterator, _a1 error) *WorkflowRegistryInterface_FilterAuthorizedAddressesUpdatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterAuthorizedAddressesUpdatedV1_Call) RunAndReturn(run func(*bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1Iterator, error)) *WorkflowRegistryInterface_FilterAuthorizedAddressesUpdatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// FilterOwnershipTransferRequested provides a mock function with given fields: opts, from, to
func (_m *WorkflowRegistryInterface) FilterOwnershipTransferRequested(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequestedIterator, error) {
	ret := _m.Called(opts, from, to)

	if len(ret) == 0 {
		panic("no return value specified for FilterOwnershipTransferRequested")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequestedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequestedIterator, error)); ok {
		return rf(opts, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequestedIterator); ok {
		r0 = rf(opts, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequestedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterOwnershipTransferRequested_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterOwnershipTransferRequested'
type WorkflowRegistryInterface_FilterOwnershipTransferRequested_Call struct {
	*mock.Call
}

// FilterOwnershipTransferRequested is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - from []common.Address
//   - to []common.Address
func (_e *WorkflowRegistryInterface_Expecter) FilterOwnershipTransferRequested(opts interface{}, from interface{}, to interface{}) *WorkflowRegistryInterface_FilterOwnershipTransferRequested_Call {
	return &WorkflowRegistryInterface_FilterOwnershipTransferRequested_Call{Call: _e.mock.On("FilterOwnershipTransferRequested", opts, from, to)}
}

func (_c *WorkflowRegistryInterface_FilterOwnershipTransferRequested_Call) Run(run func(opts *bind.FilterOpts, from []common.Address, to []common.Address)) *WorkflowRegistryInterface_FilterOwnershipTransferRequested_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]common.Address), args[2].([]common.Address))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterOwnershipTransferRequested_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequestedIterator, _a1 error) *WorkflowRegistryInterface_FilterOwnershipTransferRequested_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterOwnershipTransferRequested_Call) RunAndReturn(run func(*bind.FilterOpts, []common.Address, []common.Address) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequestedIterator, error)) *WorkflowRegistryInterface_FilterOwnershipTransferRequested_Call {
	_c.Call.Return(run)
	return _c
}

// FilterOwnershipTransferred provides a mock function with given fields: opts, from, to
func (_m *WorkflowRegistryInterface) FilterOwnershipTransferred(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferredIterator, error) {
	ret := _m.Called(opts, from, to)

	if len(ret) == 0 {
		panic("no return value specified for FilterOwnershipTransferred")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferredIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferredIterator, error)); ok {
		return rf(opts, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferredIterator); ok {
		r0 = rf(opts, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferredIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterOwnershipTransferred_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterOwnershipTransferred'
type WorkflowRegistryInterface_FilterOwnershipTransferred_Call struct {
	*mock.Call
}

// FilterOwnershipTransferred is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - from []common.Address
//   - to []common.Address
func (_e *WorkflowRegistryInterface_Expecter) FilterOwnershipTransferred(opts interface{}, from interface{}, to interface{}) *WorkflowRegistryInterface_FilterOwnershipTransferred_Call {
	return &WorkflowRegistryInterface_FilterOwnershipTransferred_Call{Call: _e.mock.On("FilterOwnershipTransferred", opts, from, to)}
}

func (_c *WorkflowRegistryInterface_FilterOwnershipTransferred_Call) Run(run func(opts *bind.FilterOpts, from []common.Address, to []common.Address)) *WorkflowRegistryInterface_FilterOwnershipTransferred_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]common.Address), args[2].([]common.Address))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterOwnershipTransferred_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferredIterator, _a1 error) *WorkflowRegistryInterface_FilterOwnershipTransferred_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterOwnershipTransferred_Call) RunAndReturn(run func(*bind.FilterOpts, []common.Address, []common.Address) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferredIterator, error)) *WorkflowRegistryInterface_FilterOwnershipTransferred_Call {
	_c.Call.Return(run)
	return _c
}

// FilterRegistryLockedV1 provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) FilterRegistryLockedV1(opts *bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1Iterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterRegistryLockedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1Iterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1Iterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1Iterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1Iterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterRegistryLockedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterRegistryLockedV1'
type WorkflowRegistryInterface_FilterRegistryLockedV1_Call struct {
	*mock.Call
}

// FilterRegistryLockedV1 is a helper method to define mock.On call
//   - opts *bind.FilterOpts
func (_e *WorkflowRegistryInterface_Expecter) FilterRegistryLockedV1(opts interface{}) *WorkflowRegistryInterface_FilterRegistryLockedV1_Call {
	return &WorkflowRegistryInterface_FilterRegistryLockedV1_Call{Call: _e.mock.On("FilterRegistryLockedV1", opts)}
}

func (_c *WorkflowRegistryInterface_FilterRegistryLockedV1_Call) Run(run func(opts *bind.FilterOpts)) *WorkflowRegistryInterface_FilterRegistryLockedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterRegistryLockedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1Iterator, _a1 error) *WorkflowRegistryInterface_FilterRegistryLockedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterRegistryLockedV1_Call) RunAndReturn(run func(*bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1Iterator, error)) *WorkflowRegistryInterface_FilterRegistryLockedV1_Call {
	_c.Call.Return(run)
	return _c
}

// FilterRegistryUnlockedV1 provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) FilterRegistryUnlockedV1(opts *bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1Iterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterRegistryUnlockedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1Iterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1Iterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1Iterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1Iterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterRegistryUnlockedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterRegistryUnlockedV1'
type WorkflowRegistryInterface_FilterRegistryUnlockedV1_Call struct {
	*mock.Call
}

// FilterRegistryUnlockedV1 is a helper method to define mock.On call
//   - opts *bind.FilterOpts
func (_e *WorkflowRegistryInterface_Expecter) FilterRegistryUnlockedV1(opts interface{}) *WorkflowRegistryInterface_FilterRegistryUnlockedV1_Call {
	return &WorkflowRegistryInterface_FilterRegistryUnlockedV1_Call{Call: _e.mock.On("FilterRegistryUnlockedV1", opts)}
}

func (_c *WorkflowRegistryInterface_FilterRegistryUnlockedV1_Call) Run(run func(opts *bind.FilterOpts)) *WorkflowRegistryInterface_FilterRegistryUnlockedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterRegistryUnlockedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1Iterator, _a1 error) *WorkflowRegistryInterface_FilterRegistryUnlockedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterRegistryUnlockedV1_Call) RunAndReturn(run func(*bind.FilterOpts) (*workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1Iterator, error)) *WorkflowRegistryInterface_FilterRegistryUnlockedV1_Call {
	_c.Call.Return(run)
	return _c
}

// FilterWorkflowActivatedV1 provides a mock function with given fields: opts, workflowID, workflowOwner, donID
func (_m *WorkflowRegistryInterface) FilterWorkflowActivatedV1(opts *bind.FilterOpts, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1Iterator, error) {
	ret := _m.Called(opts, workflowID, workflowOwner, donID)

	if len(ret) == 0 {
		panic("no return value specified for FilterWorkflowActivatedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1Iterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1Iterator, error)); ok {
		return rf(opts, workflowID, workflowOwner, donID)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1Iterator); ok {
		r0 = rf(opts, workflowID, workflowOwner, donID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1Iterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) error); ok {
		r1 = rf(opts, workflowID, workflowOwner, donID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterWorkflowActivatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterWorkflowActivatedV1'
type WorkflowRegistryInterface_FilterWorkflowActivatedV1_Call struct {
	*mock.Call
}

// FilterWorkflowActivatedV1 is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - workflowID [][32]byte
//   - workflowOwner []common.Address
//   - donID []uint32
func (_e *WorkflowRegistryInterface_Expecter) FilterWorkflowActivatedV1(opts interface{}, workflowID interface{}, workflowOwner interface{}, donID interface{}) *WorkflowRegistryInterface_FilterWorkflowActivatedV1_Call {
	return &WorkflowRegistryInterface_FilterWorkflowActivatedV1_Call{Call: _e.mock.On("FilterWorkflowActivatedV1", opts, workflowID, workflowOwner, donID)}
}

func (_c *WorkflowRegistryInterface_FilterWorkflowActivatedV1_Call) Run(run func(opts *bind.FilterOpts, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32)) *WorkflowRegistryInterface_FilterWorkflowActivatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte), args[2].([]common.Address), args[3].([]uint32))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowActivatedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1Iterator, _a1 error) *WorkflowRegistryInterface_FilterWorkflowActivatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowActivatedV1_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1Iterator, error)) *WorkflowRegistryInterface_FilterWorkflowActivatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// FilterWorkflowDeletedV1 provides a mock function with given fields: opts, workflowID, workflowOwner, donID
func (_m *WorkflowRegistryInterface) FilterWorkflowDeletedV1(opts *bind.FilterOpts, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1Iterator, error) {
	ret := _m.Called(opts, workflowID, workflowOwner, donID)

	if len(ret) == 0 {
		panic("no return value specified for FilterWorkflowDeletedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1Iterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1Iterator, error)); ok {
		return rf(opts, workflowID, workflowOwner, donID)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1Iterator); ok {
		r0 = rf(opts, workflowID, workflowOwner, donID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1Iterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) error); ok {
		r1 = rf(opts, workflowID, workflowOwner, donID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterWorkflowDeletedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterWorkflowDeletedV1'
type WorkflowRegistryInterface_FilterWorkflowDeletedV1_Call struct {
	*mock.Call
}

// FilterWorkflowDeletedV1 is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - workflowID [][32]byte
//   - workflowOwner []common.Address
//   - donID []uint32
func (_e *WorkflowRegistryInterface_Expecter) FilterWorkflowDeletedV1(opts interface{}, workflowID interface{}, workflowOwner interface{}, donID interface{}) *WorkflowRegistryInterface_FilterWorkflowDeletedV1_Call {
	return &WorkflowRegistryInterface_FilterWorkflowDeletedV1_Call{Call: _e.mock.On("FilterWorkflowDeletedV1", opts, workflowID, workflowOwner, donID)}
}

func (_c *WorkflowRegistryInterface_FilterWorkflowDeletedV1_Call) Run(run func(opts *bind.FilterOpts, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32)) *WorkflowRegistryInterface_FilterWorkflowDeletedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte), args[2].([]common.Address), args[3].([]uint32))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowDeletedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1Iterator, _a1 error) *WorkflowRegistryInterface_FilterWorkflowDeletedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowDeletedV1_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1Iterator, error)) *WorkflowRegistryInterface_FilterWorkflowDeletedV1_Call {
	_c.Call.Return(run)
	return _c
}

// FilterWorkflowForceUpdateSecretsRequestedV1 provides a mock function with given fields: opts, owner
func (_m *WorkflowRegistryInterface) FilterWorkflowForceUpdateSecretsRequestedV1(opts *bind.FilterOpts, owner []common.Address) (*workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1Iterator, error) {
	ret := _m.Called(opts, owner)

	if len(ret) == 0 {
		panic("no return value specified for FilterWorkflowForceUpdateSecretsRequestedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1Iterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) (*workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1Iterator, error)); ok {
		return rf(opts, owner)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1Iterator); ok {
		r0 = rf(opts, owner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1Iterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address) error); ok {
		r1 = rf(opts, owner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterWorkflowForceUpdateSecretsRequestedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterWorkflowForceUpdateSecretsRequestedV1'
type WorkflowRegistryInterface_FilterWorkflowForceUpdateSecretsRequestedV1_Call struct {
	*mock.Call
}

// FilterWorkflowForceUpdateSecretsRequestedV1 is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - owner []common.Address
func (_e *WorkflowRegistryInterface_Expecter) FilterWorkflowForceUpdateSecretsRequestedV1(opts interface{}, owner interface{}) *WorkflowRegistryInterface_FilterWorkflowForceUpdateSecretsRequestedV1_Call {
	return &WorkflowRegistryInterface_FilterWorkflowForceUpdateSecretsRequestedV1_Call{Call: _e.mock.On("FilterWorkflowForceUpdateSecretsRequestedV1", opts, owner)}
}

func (_c *WorkflowRegistryInterface_FilterWorkflowForceUpdateSecretsRequestedV1_Call) Run(run func(opts *bind.FilterOpts, owner []common.Address)) *WorkflowRegistryInterface_FilterWorkflowForceUpdateSecretsRequestedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]common.Address))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowForceUpdateSecretsRequestedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1Iterator, _a1 error) *WorkflowRegistryInterface_FilterWorkflowForceUpdateSecretsRequestedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowForceUpdateSecretsRequestedV1_Call) RunAndReturn(run func(*bind.FilterOpts, []common.Address) (*workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1Iterator, error)) *WorkflowRegistryInterface_FilterWorkflowForceUpdateSecretsRequestedV1_Call {
	_c.Call.Return(run)
	return _c
}

// FilterWorkflowPausedV1 provides a mock function with given fields: opts, workflowID, workflowOwner, donID
func (_m *WorkflowRegistryInterface) FilterWorkflowPausedV1(opts *bind.FilterOpts, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1Iterator, error) {
	ret := _m.Called(opts, workflowID, workflowOwner, donID)

	if len(ret) == 0 {
		panic("no return value specified for FilterWorkflowPausedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1Iterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1Iterator, error)); ok {
		return rf(opts, workflowID, workflowOwner, donID)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1Iterator); ok {
		r0 = rf(opts, workflowID, workflowOwner, donID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1Iterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) error); ok {
		r1 = rf(opts, workflowID, workflowOwner, donID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterWorkflowPausedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterWorkflowPausedV1'
type WorkflowRegistryInterface_FilterWorkflowPausedV1_Call struct {
	*mock.Call
}

// FilterWorkflowPausedV1 is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - workflowID [][32]byte
//   - workflowOwner []common.Address
//   - donID []uint32
func (_e *WorkflowRegistryInterface_Expecter) FilterWorkflowPausedV1(opts interface{}, workflowID interface{}, workflowOwner interface{}, donID interface{}) *WorkflowRegistryInterface_FilterWorkflowPausedV1_Call {
	return &WorkflowRegistryInterface_FilterWorkflowPausedV1_Call{Call: _e.mock.On("FilterWorkflowPausedV1", opts, workflowID, workflowOwner, donID)}
}

func (_c *WorkflowRegistryInterface_FilterWorkflowPausedV1_Call) Run(run func(opts *bind.FilterOpts, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32)) *WorkflowRegistryInterface_FilterWorkflowPausedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte), args[2].([]common.Address), args[3].([]uint32))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowPausedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1Iterator, _a1 error) *WorkflowRegistryInterface_FilterWorkflowPausedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowPausedV1_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1Iterator, error)) *WorkflowRegistryInterface_FilterWorkflowPausedV1_Call {
	_c.Call.Return(run)
	return _c
}

// FilterWorkflowRegisteredV1 provides a mock function with given fields: opts, workflowID, workflowOwner, donID
func (_m *WorkflowRegistryInterface) FilterWorkflowRegisteredV1(opts *bind.FilterOpts, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1Iterator, error) {
	ret := _m.Called(opts, workflowID, workflowOwner, donID)

	if len(ret) == 0 {
		panic("no return value specified for FilterWorkflowRegisteredV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1Iterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1Iterator, error)); ok {
		return rf(opts, workflowID, workflowOwner, donID)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1Iterator); ok {
		r0 = rf(opts, workflowID, workflowOwner, donID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1Iterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) error); ok {
		r1 = rf(opts, workflowID, workflowOwner, donID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterWorkflowRegisteredV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterWorkflowRegisteredV1'
type WorkflowRegistryInterface_FilterWorkflowRegisteredV1_Call struct {
	*mock.Call
}

// FilterWorkflowRegisteredV1 is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - workflowID [][32]byte
//   - workflowOwner []common.Address
//   - donID []uint32
func (_e *WorkflowRegistryInterface_Expecter) FilterWorkflowRegisteredV1(opts interface{}, workflowID interface{}, workflowOwner interface{}, donID interface{}) *WorkflowRegistryInterface_FilterWorkflowRegisteredV1_Call {
	return &WorkflowRegistryInterface_FilterWorkflowRegisteredV1_Call{Call: _e.mock.On("FilterWorkflowRegisteredV1", opts, workflowID, workflowOwner, donID)}
}

func (_c *WorkflowRegistryInterface_FilterWorkflowRegisteredV1_Call) Run(run func(opts *bind.FilterOpts, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32)) *WorkflowRegistryInterface_FilterWorkflowRegisteredV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte), args[2].([]common.Address), args[3].([]uint32))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowRegisteredV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1Iterator, _a1 error) *WorkflowRegistryInterface_FilterWorkflowRegisteredV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowRegisteredV1_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1Iterator, error)) *WorkflowRegistryInterface_FilterWorkflowRegisteredV1_Call {
	_c.Call.Return(run)
	return _c
}

// FilterWorkflowUpdatedV1 provides a mock function with given fields: opts, oldWorkflowID, workflowOwner, donID
func (_m *WorkflowRegistryInterface) FilterWorkflowUpdatedV1(opts *bind.FilterOpts, oldWorkflowID [][32]byte, workflowOwner []common.Address, donID []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1Iterator, error) {
	ret := _m.Called(opts, oldWorkflowID, workflowOwner, donID)

	if len(ret) == 0 {
		panic("no return value specified for FilterWorkflowUpdatedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1Iterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1Iterator, error)); ok {
		return rf(opts, oldWorkflowID, workflowOwner, donID)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1Iterator); ok {
		r0 = rf(opts, oldWorkflowID, workflowOwner, donID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1Iterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) error); ok {
		r1 = rf(opts, oldWorkflowID, workflowOwner, donID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_FilterWorkflowUpdatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterWorkflowUpdatedV1'
type WorkflowRegistryInterface_FilterWorkflowUpdatedV1_Call struct {
	*mock.Call
}

// FilterWorkflowUpdatedV1 is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - oldWorkflowID [][32]byte
//   - workflowOwner []common.Address
//   - donID []uint32
func (_e *WorkflowRegistryInterface_Expecter) FilterWorkflowUpdatedV1(opts interface{}, oldWorkflowID interface{}, workflowOwner interface{}, donID interface{}) *WorkflowRegistryInterface_FilterWorkflowUpdatedV1_Call {
	return &WorkflowRegistryInterface_FilterWorkflowUpdatedV1_Call{Call: _e.mock.On("FilterWorkflowUpdatedV1", opts, oldWorkflowID, workflowOwner, donID)}
}

func (_c *WorkflowRegistryInterface_FilterWorkflowUpdatedV1_Call) Run(run func(opts *bind.FilterOpts, oldWorkflowID [][32]byte, workflowOwner []common.Address, donID []uint32)) *WorkflowRegistryInterface_FilterWorkflowUpdatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte), args[2].([]common.Address), args[3].([]uint32))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowUpdatedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1Iterator, _a1 error) *WorkflowRegistryInterface_FilterWorkflowUpdatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_FilterWorkflowUpdatedV1_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte, []common.Address, []uint32) (*workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1Iterator, error)) *WorkflowRegistryInterface_FilterWorkflowUpdatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllAllowedDONs provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) GetAllAllowedDONs(opts *bind.CallOpts) ([]uint32, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetAllAllowedDONs")
	}

	var r0 []uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([]uint32, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []uint32); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint32)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_GetAllAllowedDONs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllAllowedDONs'
type WorkflowRegistryInterface_GetAllAllowedDONs_Call struct {
	*mock.Call
}

// GetAllAllowedDONs is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *WorkflowRegistryInterface_Expecter) GetAllAllowedDONs(opts interface{}) *WorkflowRegistryInterface_GetAllAllowedDONs_Call {
	return &WorkflowRegistryInterface_GetAllAllowedDONs_Call{Call: _e.mock.On("GetAllAllowedDONs", opts)}
}

func (_c *WorkflowRegistryInterface_GetAllAllowedDONs_Call) Run(run func(opts *bind.CallOpts)) *WorkflowRegistryInterface_GetAllAllowedDONs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_GetAllAllowedDONs_Call) Return(_a0 []uint32, _a1 error) *WorkflowRegistryInterface_GetAllAllowedDONs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_GetAllAllowedDONs_Call) RunAndReturn(run func(*bind.CallOpts) ([]uint32, error)) *WorkflowRegistryInterface_GetAllAllowedDONs_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllAuthorizedAddresses provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) GetAllAuthorizedAddresses(opts *bind.CallOpts) ([]common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetAllAuthorizedAddresses")
	}

	var r0 []common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([]common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_GetAllAuthorizedAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllAuthorizedAddresses'
type WorkflowRegistryInterface_GetAllAuthorizedAddresses_Call struct {
	*mock.Call
}

// GetAllAuthorizedAddresses is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *WorkflowRegistryInterface_Expecter) GetAllAuthorizedAddresses(opts interface{}) *WorkflowRegistryInterface_GetAllAuthorizedAddresses_Call {
	return &WorkflowRegistryInterface_GetAllAuthorizedAddresses_Call{Call: _e.mock.On("GetAllAuthorizedAddresses", opts)}
}

func (_c *WorkflowRegistryInterface_GetAllAuthorizedAddresses_Call) Run(run func(opts *bind.CallOpts)) *WorkflowRegistryInterface_GetAllAuthorizedAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_GetAllAuthorizedAddresses_Call) Return(_a0 []common.Address, _a1 error) *WorkflowRegistryInterface_GetAllAuthorizedAddresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_GetAllAuthorizedAddresses_Call) RunAndReturn(run func(*bind.CallOpts) ([]common.Address, error)) *WorkflowRegistryInterface_GetAllAuthorizedAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowMetadata provides a mock function with given fields: opts, workflowOwner, workflowName
func (_m *WorkflowRegistryInterface) GetWorkflowMetadata(opts *bind.CallOpts, workflowOwner common.Address, workflowName string) (workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, error) {
	ret := _m.Called(opts, workflowOwner, workflowName)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowMetadata")
	}

	var r0 workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address, string) (workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, error)); ok {
		return rf(opts, workflowOwner, workflowName)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address, string) workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata); ok {
		r0 = rf(opts, workflowOwner, workflowName)
	} else {
		r0 = ret.Get(0).(workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address, string) error); ok {
		r1 = rf(opts, workflowOwner, workflowName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_GetWorkflowMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowMetadata'
type WorkflowRegistryInterface_GetWorkflowMetadata_Call struct {
	*mock.Call
}

// GetWorkflowMetadata is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - workflowOwner common.Address
//   - workflowName string
func (_e *WorkflowRegistryInterface_Expecter) GetWorkflowMetadata(opts interface{}, workflowOwner interface{}, workflowName interface{}) *WorkflowRegistryInterface_GetWorkflowMetadata_Call {
	return &WorkflowRegistryInterface_GetWorkflowMetadata_Call{Call: _e.mock.On("GetWorkflowMetadata", opts, workflowOwner, workflowName)}
}

func (_c *WorkflowRegistryInterface_GetWorkflowMetadata_Call) Run(run func(opts *bind.CallOpts, workflowOwner common.Address, workflowName string)) *WorkflowRegistryInterface_GetWorkflowMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(common.Address), args[2].(string))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_GetWorkflowMetadata_Call) Return(_a0 workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, _a1 error) *WorkflowRegistryInterface_GetWorkflowMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_GetWorkflowMetadata_Call) RunAndReturn(run func(*bind.CallOpts, common.Address, string) (workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, error)) *WorkflowRegistryInterface_GetWorkflowMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowMetadataListByDON provides a mock function with given fields: opts, donID, start, limit
func (_m *WorkflowRegistryInterface) GetWorkflowMetadataListByDON(opts *bind.CallOpts, donID uint32, start *big.Int, limit *big.Int) ([]workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, error) {
	ret := _m.Called(opts, donID, start, limit)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowMetadataListByDON")
	}

	var r0 []workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32, *big.Int, *big.Int) ([]workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, error)); ok {
		return rf(opts, donID, start, limit)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32, *big.Int, *big.Int) []workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata); ok {
		r0 = rf(opts, donID, start, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32, *big.Int, *big.Int) error); ok {
		r1 = rf(opts, donID, start, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_GetWorkflowMetadataListByDON_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowMetadataListByDON'
type WorkflowRegistryInterface_GetWorkflowMetadataListByDON_Call struct {
	*mock.Call
}

// GetWorkflowMetadataListByDON is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - donID uint32
//   - start *big.Int
//   - limit *big.Int
func (_e *WorkflowRegistryInterface_Expecter) GetWorkflowMetadataListByDON(opts interface{}, donID interface{}, start interface{}, limit interface{}) *WorkflowRegistryInterface_GetWorkflowMetadataListByDON_Call {
	return &WorkflowRegistryInterface_GetWorkflowMetadataListByDON_Call{Call: _e.mock.On("GetWorkflowMetadataListByDON", opts, donID, start, limit)}
}

func (_c *WorkflowRegistryInterface_GetWorkflowMetadataListByDON_Call) Run(run func(opts *bind.CallOpts, donID uint32, start *big.Int, limit *big.Int)) *WorkflowRegistryInterface_GetWorkflowMetadataListByDON_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(uint32), args[2].(*big.Int), args[3].(*big.Int))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_GetWorkflowMetadataListByDON_Call) Return(_a0 []workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, _a1 error) *WorkflowRegistryInterface_GetWorkflowMetadataListByDON_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_GetWorkflowMetadataListByDON_Call) RunAndReturn(run func(*bind.CallOpts, uint32, *big.Int, *big.Int) ([]workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, error)) *WorkflowRegistryInterface_GetWorkflowMetadataListByDON_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowMetadataListByOwner provides a mock function with given fields: opts, workflowOwner, start, limit
func (_m *WorkflowRegistryInterface) GetWorkflowMetadataListByOwner(opts *bind.CallOpts, workflowOwner common.Address, start *big.Int, limit *big.Int) ([]workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, error) {
	ret := _m.Called(opts, workflowOwner, start, limit)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowMetadataListByOwner")
	}

	var r0 []workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address, *big.Int, *big.Int) ([]workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, error)); ok {
		return rf(opts, workflowOwner, start, limit)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address, *big.Int, *big.Int) []workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata); ok {
		r0 = rf(opts, workflowOwner, start, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address, *big.Int, *big.Int) error); ok {
		r1 = rf(opts, workflowOwner, start, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_GetWorkflowMetadataListByOwner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowMetadataListByOwner'
type WorkflowRegistryInterface_GetWorkflowMetadataListByOwner_Call struct {
	*mock.Call
}

// GetWorkflowMetadataListByOwner is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - workflowOwner common.Address
//   - start *big.Int
//   - limit *big.Int
func (_e *WorkflowRegistryInterface_Expecter) GetWorkflowMetadataListByOwner(opts interface{}, workflowOwner interface{}, start interface{}, limit interface{}) *WorkflowRegistryInterface_GetWorkflowMetadataListByOwner_Call {
	return &WorkflowRegistryInterface_GetWorkflowMetadataListByOwner_Call{Call: _e.mock.On("GetWorkflowMetadataListByOwner", opts, workflowOwner, start, limit)}
}

func (_c *WorkflowRegistryInterface_GetWorkflowMetadataListByOwner_Call) Run(run func(opts *bind.CallOpts, workflowOwner common.Address, start *big.Int, limit *big.Int)) *WorkflowRegistryInterface_GetWorkflowMetadataListByOwner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(common.Address), args[2].(*big.Int), args[3].(*big.Int))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_GetWorkflowMetadataListByOwner_Call) Return(_a0 []workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, _a1 error) *WorkflowRegistryInterface_GetWorkflowMetadataListByOwner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_GetWorkflowMetadataListByOwner_Call) RunAndReturn(run func(*bind.CallOpts, common.Address, *big.Int, *big.Int) ([]workflow_registry_wrapper.WorkflowRegistryWorkflowMetadata, error)) *WorkflowRegistryInterface_GetWorkflowMetadataListByOwner_Call {
	_c.Call.Return(run)
	return _c
}

// IsRegistryLocked provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) IsRegistryLocked(opts *bind.CallOpts) (bool, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for IsRegistryLocked")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (bool, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) bool); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_IsRegistryLocked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsRegistryLocked'
type WorkflowRegistryInterface_IsRegistryLocked_Call struct {
	*mock.Call
}

// IsRegistryLocked is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *WorkflowRegistryInterface_Expecter) IsRegistryLocked(opts interface{}) *WorkflowRegistryInterface_IsRegistryLocked_Call {
	return &WorkflowRegistryInterface_IsRegistryLocked_Call{Call: _e.mock.On("IsRegistryLocked", opts)}
}

func (_c *WorkflowRegistryInterface_IsRegistryLocked_Call) Run(run func(opts *bind.CallOpts)) *WorkflowRegistryInterface_IsRegistryLocked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_IsRegistryLocked_Call) Return(_a0 bool, _a1 error) *WorkflowRegistryInterface_IsRegistryLocked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_IsRegistryLocked_Call) RunAndReturn(run func(*bind.CallOpts) (bool, error)) *WorkflowRegistryInterface_IsRegistryLocked_Call {
	_c.Call.Return(run)
	return _c
}

// LockRegistry provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) LockRegistry(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LockRegistry")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_LockRegistry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockRegistry'
type WorkflowRegistryInterface_LockRegistry_Call struct {
	*mock.Call
}

// LockRegistry is a helper method to define mock.On call
//   - opts *bind.TransactOpts
func (_e *WorkflowRegistryInterface_Expecter) LockRegistry(opts interface{}) *WorkflowRegistryInterface_LockRegistry_Call {
	return &WorkflowRegistryInterface_LockRegistry_Call{Call: _e.mock.On("LockRegistry", opts)}
}

func (_c *WorkflowRegistryInterface_LockRegistry_Call) Run(run func(opts *bind.TransactOpts)) *WorkflowRegistryInterface_LockRegistry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_LockRegistry_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_LockRegistry_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_LockRegistry_Call) RunAndReturn(run func(*bind.TransactOpts) (*types.Transaction, error)) *WorkflowRegistryInterface_LockRegistry_Call {
	_c.Call.Return(run)
	return _c
}

// Owner provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) Owner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Owner")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_Owner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Owner'
type WorkflowRegistryInterface_Owner_Call struct {
	*mock.Call
}

// Owner is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *WorkflowRegistryInterface_Expecter) Owner(opts interface{}) *WorkflowRegistryInterface_Owner_Call {
	return &WorkflowRegistryInterface_Owner_Call{Call: _e.mock.On("Owner", opts)}
}

func (_c *WorkflowRegistryInterface_Owner_Call) Run(run func(opts *bind.CallOpts)) *WorkflowRegistryInterface_Owner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_Owner_Call) Return(_a0 common.Address, _a1 error) *WorkflowRegistryInterface_Owner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_Owner_Call) RunAndReturn(run func(*bind.CallOpts) (common.Address, error)) *WorkflowRegistryInterface_Owner_Call {
	_c.Call.Return(run)
	return _c
}

// ParseAllowedDONsUpdatedV1 provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseAllowedDONsUpdatedV1(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseAllowedDONsUpdatedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseAllowedDONsUpdatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseAllowedDONsUpdatedV1'
type WorkflowRegistryInterface_ParseAllowedDONsUpdatedV1_Call struct {
	*mock.Call
}

// ParseAllowedDONsUpdatedV1 is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseAllowedDONsUpdatedV1(log interface{}) *WorkflowRegistryInterface_ParseAllowedDONsUpdatedV1_Call {
	return &WorkflowRegistryInterface_ParseAllowedDONsUpdatedV1_Call{Call: _e.mock.On("ParseAllowedDONsUpdatedV1", log)}
}

func (_c *WorkflowRegistryInterface_ParseAllowedDONsUpdatedV1_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseAllowedDONsUpdatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseAllowedDONsUpdatedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1, _a1 error) *WorkflowRegistryInterface_ParseAllowedDONsUpdatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseAllowedDONsUpdatedV1_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1, error)) *WorkflowRegistryInterface_ParseAllowedDONsUpdatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// ParseAuthorizedAddressesUpdatedV1 provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseAuthorizedAddressesUpdatedV1(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseAuthorizedAddressesUpdatedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseAuthorizedAddressesUpdatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseAuthorizedAddressesUpdatedV1'
type WorkflowRegistryInterface_ParseAuthorizedAddressesUpdatedV1_Call struct {
	*mock.Call
}

// ParseAuthorizedAddressesUpdatedV1 is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseAuthorizedAddressesUpdatedV1(log interface{}) *WorkflowRegistryInterface_ParseAuthorizedAddressesUpdatedV1_Call {
	return &WorkflowRegistryInterface_ParseAuthorizedAddressesUpdatedV1_Call{Call: _e.mock.On("ParseAuthorizedAddressesUpdatedV1", log)}
}

func (_c *WorkflowRegistryInterface_ParseAuthorizedAddressesUpdatedV1_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseAuthorizedAddressesUpdatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseAuthorizedAddressesUpdatedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1, _a1 error) *WorkflowRegistryInterface_ParseAuthorizedAddressesUpdatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseAuthorizedAddressesUpdatedV1_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1, error)) *WorkflowRegistryInterface_ParseAuthorizedAddressesUpdatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// ParseLog provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseLog(log types.Log) (generated.AbigenLog, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseLog")
	}

	var r0 generated.AbigenLog
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (generated.AbigenLog, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) generated.AbigenLog); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(generated.AbigenLog)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseLog'
type WorkflowRegistryInterface_ParseLog_Call struct {
	*mock.Call
}

// ParseLog is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseLog(log interface{}) *WorkflowRegistryInterface_ParseLog_Call {
	return &WorkflowRegistryInterface_ParseLog_Call{Call: _e.mock.On("ParseLog", log)}
}

func (_c *WorkflowRegistryInterface_ParseLog_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseLog_Call) Return(_a0 generated.AbigenLog, _a1 error) *WorkflowRegistryInterface_ParseLog_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseLog_Call) RunAndReturn(run func(types.Log) (generated.AbigenLog, error)) *WorkflowRegistryInterface_ParseLog_Call {
	_c.Call.Return(run)
	return _c
}

// ParseOwnershipTransferRequested provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseOwnershipTransferRequested(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOwnershipTransferRequested")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseOwnershipTransferRequested_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseOwnershipTransferRequested'
type WorkflowRegistryInterface_ParseOwnershipTransferRequested_Call struct {
	*mock.Call
}

// ParseOwnershipTransferRequested is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseOwnershipTransferRequested(log interface{}) *WorkflowRegistryInterface_ParseOwnershipTransferRequested_Call {
	return &WorkflowRegistryInterface_ParseOwnershipTransferRequested_Call{Call: _e.mock.On("ParseOwnershipTransferRequested", log)}
}

func (_c *WorkflowRegistryInterface_ParseOwnershipTransferRequested_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseOwnershipTransferRequested_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseOwnershipTransferRequested_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested, _a1 error) *WorkflowRegistryInterface_ParseOwnershipTransferRequested_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseOwnershipTransferRequested_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested, error)) *WorkflowRegistryInterface_ParseOwnershipTransferRequested_Call {
	_c.Call.Return(run)
	return _c
}

// ParseOwnershipTransferred provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseOwnershipTransferred(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOwnershipTransferred")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseOwnershipTransferred_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseOwnershipTransferred'
type WorkflowRegistryInterface_ParseOwnershipTransferred_Call struct {
	*mock.Call
}

// ParseOwnershipTransferred is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseOwnershipTransferred(log interface{}) *WorkflowRegistryInterface_ParseOwnershipTransferred_Call {
	return &WorkflowRegistryInterface_ParseOwnershipTransferred_Call{Call: _e.mock.On("ParseOwnershipTransferred", log)}
}

func (_c *WorkflowRegistryInterface_ParseOwnershipTransferred_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseOwnershipTransferred_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseOwnershipTransferred_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred, _a1 error) *WorkflowRegistryInterface_ParseOwnershipTransferred_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseOwnershipTransferred_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred, error)) *WorkflowRegistryInterface_ParseOwnershipTransferred_Call {
	_c.Call.Return(run)
	return _c
}

// ParseRegistryLockedV1 provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseRegistryLockedV1(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseRegistryLockedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseRegistryLockedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseRegistryLockedV1'
type WorkflowRegistryInterface_ParseRegistryLockedV1_Call struct {
	*mock.Call
}

// ParseRegistryLockedV1 is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseRegistryLockedV1(log interface{}) *WorkflowRegistryInterface_ParseRegistryLockedV1_Call {
	return &WorkflowRegistryInterface_ParseRegistryLockedV1_Call{Call: _e.mock.On("ParseRegistryLockedV1", log)}
}

func (_c *WorkflowRegistryInterface_ParseRegistryLockedV1_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseRegistryLockedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseRegistryLockedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1, _a1 error) *WorkflowRegistryInterface_ParseRegistryLockedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseRegistryLockedV1_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1, error)) *WorkflowRegistryInterface_ParseRegistryLockedV1_Call {
	_c.Call.Return(run)
	return _c
}

// ParseRegistryUnlockedV1 provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseRegistryUnlockedV1(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseRegistryUnlockedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseRegistryUnlockedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseRegistryUnlockedV1'
type WorkflowRegistryInterface_ParseRegistryUnlockedV1_Call struct {
	*mock.Call
}

// ParseRegistryUnlockedV1 is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseRegistryUnlockedV1(log interface{}) *WorkflowRegistryInterface_ParseRegistryUnlockedV1_Call {
	return &WorkflowRegistryInterface_ParseRegistryUnlockedV1_Call{Call: _e.mock.On("ParseRegistryUnlockedV1", log)}
}

func (_c *WorkflowRegistryInterface_ParseRegistryUnlockedV1_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseRegistryUnlockedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseRegistryUnlockedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1, _a1 error) *WorkflowRegistryInterface_ParseRegistryUnlockedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseRegistryUnlockedV1_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1, error)) *WorkflowRegistryInterface_ParseRegistryUnlockedV1_Call {
	_c.Call.Return(run)
	return _c
}

// ParseWorkflowActivatedV1 provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseWorkflowActivatedV1(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseWorkflowActivatedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseWorkflowActivatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseWorkflowActivatedV1'
type WorkflowRegistryInterface_ParseWorkflowActivatedV1_Call struct {
	*mock.Call
}

// ParseWorkflowActivatedV1 is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseWorkflowActivatedV1(log interface{}) *WorkflowRegistryInterface_ParseWorkflowActivatedV1_Call {
	return &WorkflowRegistryInterface_ParseWorkflowActivatedV1_Call{Call: _e.mock.On("ParseWorkflowActivatedV1", log)}
}

func (_c *WorkflowRegistryInterface_ParseWorkflowActivatedV1_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseWorkflowActivatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowActivatedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1, _a1 error) *WorkflowRegistryInterface_ParseWorkflowActivatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowActivatedV1_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1, error)) *WorkflowRegistryInterface_ParseWorkflowActivatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// ParseWorkflowDeletedV1 provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseWorkflowDeletedV1(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseWorkflowDeletedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseWorkflowDeletedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseWorkflowDeletedV1'
type WorkflowRegistryInterface_ParseWorkflowDeletedV1_Call struct {
	*mock.Call
}

// ParseWorkflowDeletedV1 is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseWorkflowDeletedV1(log interface{}) *WorkflowRegistryInterface_ParseWorkflowDeletedV1_Call {
	return &WorkflowRegistryInterface_ParseWorkflowDeletedV1_Call{Call: _e.mock.On("ParseWorkflowDeletedV1", log)}
}

func (_c *WorkflowRegistryInterface_ParseWorkflowDeletedV1_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseWorkflowDeletedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowDeletedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1, _a1 error) *WorkflowRegistryInterface_ParseWorkflowDeletedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowDeletedV1_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1, error)) *WorkflowRegistryInterface_ParseWorkflowDeletedV1_Call {
	_c.Call.Return(run)
	return _c
}

// ParseWorkflowForceUpdateSecretsRequestedV1 provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseWorkflowForceUpdateSecretsRequestedV1(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseWorkflowForceUpdateSecretsRequestedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseWorkflowForceUpdateSecretsRequestedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseWorkflowForceUpdateSecretsRequestedV1'
type WorkflowRegistryInterface_ParseWorkflowForceUpdateSecretsRequestedV1_Call struct {
	*mock.Call
}

// ParseWorkflowForceUpdateSecretsRequestedV1 is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseWorkflowForceUpdateSecretsRequestedV1(log interface{}) *WorkflowRegistryInterface_ParseWorkflowForceUpdateSecretsRequestedV1_Call {
	return &WorkflowRegistryInterface_ParseWorkflowForceUpdateSecretsRequestedV1_Call{Call: _e.mock.On("ParseWorkflowForceUpdateSecretsRequestedV1", log)}
}

func (_c *WorkflowRegistryInterface_ParseWorkflowForceUpdateSecretsRequestedV1_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseWorkflowForceUpdateSecretsRequestedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowForceUpdateSecretsRequestedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1, _a1 error) *WorkflowRegistryInterface_ParseWorkflowForceUpdateSecretsRequestedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowForceUpdateSecretsRequestedV1_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1, error)) *WorkflowRegistryInterface_ParseWorkflowForceUpdateSecretsRequestedV1_Call {
	_c.Call.Return(run)
	return _c
}

// ParseWorkflowPausedV1 provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseWorkflowPausedV1(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseWorkflowPausedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseWorkflowPausedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseWorkflowPausedV1'
type WorkflowRegistryInterface_ParseWorkflowPausedV1_Call struct {
	*mock.Call
}

// ParseWorkflowPausedV1 is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseWorkflowPausedV1(log interface{}) *WorkflowRegistryInterface_ParseWorkflowPausedV1_Call {
	return &WorkflowRegistryInterface_ParseWorkflowPausedV1_Call{Call: _e.mock.On("ParseWorkflowPausedV1", log)}
}

func (_c *WorkflowRegistryInterface_ParseWorkflowPausedV1_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseWorkflowPausedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowPausedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1, _a1 error) *WorkflowRegistryInterface_ParseWorkflowPausedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowPausedV1_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1, error)) *WorkflowRegistryInterface_ParseWorkflowPausedV1_Call {
	_c.Call.Return(run)
	return _c
}

// ParseWorkflowRegisteredV1 provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseWorkflowRegisteredV1(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseWorkflowRegisteredV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseWorkflowRegisteredV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseWorkflowRegisteredV1'
type WorkflowRegistryInterface_ParseWorkflowRegisteredV1_Call struct {
	*mock.Call
}

// ParseWorkflowRegisteredV1 is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseWorkflowRegisteredV1(log interface{}) *WorkflowRegistryInterface_ParseWorkflowRegisteredV1_Call {
	return &WorkflowRegistryInterface_ParseWorkflowRegisteredV1_Call{Call: _e.mock.On("ParseWorkflowRegisteredV1", log)}
}

func (_c *WorkflowRegistryInterface_ParseWorkflowRegisteredV1_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseWorkflowRegisteredV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowRegisteredV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1, _a1 error) *WorkflowRegistryInterface_ParseWorkflowRegisteredV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowRegisteredV1_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1, error)) *WorkflowRegistryInterface_ParseWorkflowRegisteredV1_Call {
	_c.Call.Return(run)
	return _c
}

// ParseWorkflowUpdatedV1 provides a mock function with given fields: log
func (_m *WorkflowRegistryInterface) ParseWorkflowUpdatedV1(log types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseWorkflowUpdatedV1")
	}

	var r0 *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_ParseWorkflowUpdatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseWorkflowUpdatedV1'
type WorkflowRegistryInterface_ParseWorkflowUpdatedV1_Call struct {
	*mock.Call
}

// ParseWorkflowUpdatedV1 is a helper method to define mock.On call
//   - log types.Log
func (_e *WorkflowRegistryInterface_Expecter) ParseWorkflowUpdatedV1(log interface{}) *WorkflowRegistryInterface_ParseWorkflowUpdatedV1_Call {
	return &WorkflowRegistryInterface_ParseWorkflowUpdatedV1_Call{Call: _e.mock.On("ParseWorkflowUpdatedV1", log)}
}

func (_c *WorkflowRegistryInterface_ParseWorkflowUpdatedV1_Call) Run(run func(log types.Log)) *WorkflowRegistryInterface_ParseWorkflowUpdatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowUpdatedV1_Call) Return(_a0 *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1, _a1 error) *WorkflowRegistryInterface_ParseWorkflowUpdatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_ParseWorkflowUpdatedV1_Call) RunAndReturn(run func(types.Log) (*workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1, error)) *WorkflowRegistryInterface_ParseWorkflowUpdatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// PauseWorkflow provides a mock function with given fields: opts, workflowKey
func (_m *WorkflowRegistryInterface) PauseWorkflow(opts *bind.TransactOpts, workflowKey [32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, workflowKey)

	if len(ret) == 0 {
		panic("no return value specified for PauseWorkflow")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte) (*types.Transaction, error)); ok {
		return rf(opts, workflowKey)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte) *types.Transaction); ok {
		r0 = rf(opts, workflowKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte) error); ok {
		r1 = rf(opts, workflowKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_PauseWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PauseWorkflow'
type WorkflowRegistryInterface_PauseWorkflow_Call struct {
	*mock.Call
}

// PauseWorkflow is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - workflowKey [32]byte
func (_e *WorkflowRegistryInterface_Expecter) PauseWorkflow(opts interface{}, workflowKey interface{}) *WorkflowRegistryInterface_PauseWorkflow_Call {
	return &WorkflowRegistryInterface_PauseWorkflow_Call{Call: _e.mock.On("PauseWorkflow", opts, workflowKey)}
}

func (_c *WorkflowRegistryInterface_PauseWorkflow_Call) Run(run func(opts *bind.TransactOpts, workflowKey [32]byte)) *WorkflowRegistryInterface_PauseWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_PauseWorkflow_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_PauseWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_PauseWorkflow_Call) RunAndReturn(run func(*bind.TransactOpts, [32]byte) (*types.Transaction, error)) *WorkflowRegistryInterface_PauseWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterWorkflow provides a mock function with given fields: opts, workflowName, workflowID, donID, status, binaryURL, configURL, secretsURL
func (_m *WorkflowRegistryInterface) RegisterWorkflow(opts *bind.TransactOpts, workflowName string, workflowID [32]byte, donID uint32, status uint8, binaryURL string, configURL string, secretsURL string) (*types.Transaction, error) {
	ret := _m.Called(opts, workflowName, workflowID, donID, status, binaryURL, configURL, secretsURL)

	if len(ret) == 0 {
		panic("no return value specified for RegisterWorkflow")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, string, [32]byte, uint32, uint8, string, string, string) (*types.Transaction, error)); ok {
		return rf(opts, workflowName, workflowID, donID, status, binaryURL, configURL, secretsURL)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, string, [32]byte, uint32, uint8, string, string, string) *types.Transaction); ok {
		r0 = rf(opts, workflowName, workflowID, donID, status, binaryURL, configURL, secretsURL)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, string, [32]byte, uint32, uint8, string, string, string) error); ok {
		r1 = rf(opts, workflowName, workflowID, donID, status, binaryURL, configURL, secretsURL)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_RegisterWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterWorkflow'
type WorkflowRegistryInterface_RegisterWorkflow_Call struct {
	*mock.Call
}

// RegisterWorkflow is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - workflowName string
//   - workflowID [32]byte
//   - donID uint32
//   - status uint8
//   - binaryURL string
//   - configURL string
//   - secretsURL string
func (_e *WorkflowRegistryInterface_Expecter) RegisterWorkflow(opts interface{}, workflowName interface{}, workflowID interface{}, donID interface{}, status interface{}, binaryURL interface{}, configURL interface{}, secretsURL interface{}) *WorkflowRegistryInterface_RegisterWorkflow_Call {
	return &WorkflowRegistryInterface_RegisterWorkflow_Call{Call: _e.mock.On("RegisterWorkflow", opts, workflowName, workflowID, donID, status, binaryURL, configURL, secretsURL)}
}

func (_c *WorkflowRegistryInterface_RegisterWorkflow_Call) Run(run func(opts *bind.TransactOpts, workflowName string, workflowID [32]byte, donID uint32, status uint8, binaryURL string, configURL string, secretsURL string)) *WorkflowRegistryInterface_RegisterWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].(string), args[2].([32]byte), args[3].(uint32), args[4].(uint8), args[5].(string), args[6].(string), args[7].(string))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_RegisterWorkflow_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_RegisterWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_RegisterWorkflow_Call) RunAndReturn(run func(*bind.TransactOpts, string, [32]byte, uint32, uint8, string, string, string) (*types.Transaction, error)) *WorkflowRegistryInterface_RegisterWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// RequestForceUpdateSecrets provides a mock function with given fields: opts, secretsURL
func (_m *WorkflowRegistryInterface) RequestForceUpdateSecrets(opts *bind.TransactOpts, secretsURL string) (*types.Transaction, error) {
	ret := _m.Called(opts, secretsURL)

	if len(ret) == 0 {
		panic("no return value specified for RequestForceUpdateSecrets")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, string) (*types.Transaction, error)); ok {
		return rf(opts, secretsURL)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, string) *types.Transaction); ok {
		r0 = rf(opts, secretsURL)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, string) error); ok {
		r1 = rf(opts, secretsURL)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_RequestForceUpdateSecrets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestForceUpdateSecrets'
type WorkflowRegistryInterface_RequestForceUpdateSecrets_Call struct {
	*mock.Call
}

// RequestForceUpdateSecrets is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - secretsURL string
func (_e *WorkflowRegistryInterface_Expecter) RequestForceUpdateSecrets(opts interface{}, secretsURL interface{}) *WorkflowRegistryInterface_RequestForceUpdateSecrets_Call {
	return &WorkflowRegistryInterface_RequestForceUpdateSecrets_Call{Call: _e.mock.On("RequestForceUpdateSecrets", opts, secretsURL)}
}

func (_c *WorkflowRegistryInterface_RequestForceUpdateSecrets_Call) Run(run func(opts *bind.TransactOpts, secretsURL string)) *WorkflowRegistryInterface_RequestForceUpdateSecrets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].(string))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_RequestForceUpdateSecrets_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_RequestForceUpdateSecrets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_RequestForceUpdateSecrets_Call) RunAndReturn(run func(*bind.TransactOpts, string) (*types.Transaction, error)) *WorkflowRegistryInterface_RequestForceUpdateSecrets_Call {
	_c.Call.Return(run)
	return _c
}

// TransferOwnership provides a mock function with given fields: opts, to
func (_m *WorkflowRegistryInterface) TransferOwnership(opts *bind.TransactOpts, to common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, to)

	if len(ret) == 0 {
		panic("no return value specified for TransferOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) (*types.Transaction, error)); ok {
		return rf(opts, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_TransferOwnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransferOwnership'
type WorkflowRegistryInterface_TransferOwnership_Call struct {
	*mock.Call
}

// TransferOwnership is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - to common.Address
func (_e *WorkflowRegistryInterface_Expecter) TransferOwnership(opts interface{}, to interface{}) *WorkflowRegistryInterface_TransferOwnership_Call {
	return &WorkflowRegistryInterface_TransferOwnership_Call{Call: _e.mock.On("TransferOwnership", opts, to)}
}

func (_c *WorkflowRegistryInterface_TransferOwnership_Call) Run(run func(opts *bind.TransactOpts, to common.Address)) *WorkflowRegistryInterface_TransferOwnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].(common.Address))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_TransferOwnership_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_TransferOwnership_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_TransferOwnership_Call) RunAndReturn(run func(*bind.TransactOpts, common.Address) (*types.Transaction, error)) *WorkflowRegistryInterface_TransferOwnership_Call {
	_c.Call.Return(run)
	return _c
}

// TypeAndVersion provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) TypeAndVersion(opts *bind.CallOpts) (string, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for TypeAndVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (string, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) string); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_TypeAndVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeAndVersion'
type WorkflowRegistryInterface_TypeAndVersion_Call struct {
	*mock.Call
}

// TypeAndVersion is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *WorkflowRegistryInterface_Expecter) TypeAndVersion(opts interface{}) *WorkflowRegistryInterface_TypeAndVersion_Call {
	return &WorkflowRegistryInterface_TypeAndVersion_Call{Call: _e.mock.On("TypeAndVersion", opts)}
}

func (_c *WorkflowRegistryInterface_TypeAndVersion_Call) Run(run func(opts *bind.CallOpts)) *WorkflowRegistryInterface_TypeAndVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_TypeAndVersion_Call) Return(_a0 string, _a1 error) *WorkflowRegistryInterface_TypeAndVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_TypeAndVersion_Call) RunAndReturn(run func(*bind.CallOpts) (string, error)) *WorkflowRegistryInterface_TypeAndVersion_Call {
	_c.Call.Return(run)
	return _c
}

// UnlockRegistry provides a mock function with given fields: opts
func (_m *WorkflowRegistryInterface) UnlockRegistry(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for UnlockRegistry")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_UnlockRegistry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlockRegistry'
type WorkflowRegistryInterface_UnlockRegistry_Call struct {
	*mock.Call
}

// UnlockRegistry is a helper method to define mock.On call
//   - opts *bind.TransactOpts
func (_e *WorkflowRegistryInterface_Expecter) UnlockRegistry(opts interface{}) *WorkflowRegistryInterface_UnlockRegistry_Call {
	return &WorkflowRegistryInterface_UnlockRegistry_Call{Call: _e.mock.On("UnlockRegistry", opts)}
}

func (_c *WorkflowRegistryInterface_UnlockRegistry_Call) Run(run func(opts *bind.TransactOpts)) *WorkflowRegistryInterface_UnlockRegistry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_UnlockRegistry_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_UnlockRegistry_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_UnlockRegistry_Call) RunAndReturn(run func(*bind.TransactOpts) (*types.Transaction, error)) *WorkflowRegistryInterface_UnlockRegistry_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAllowedDONs provides a mock function with given fields: opts, donIDs, allowed
func (_m *WorkflowRegistryInterface) UpdateAllowedDONs(opts *bind.TransactOpts, donIDs []uint32, allowed bool) (*types.Transaction, error) {
	ret := _m.Called(opts, donIDs, allowed)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAllowedDONs")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []uint32, bool) (*types.Transaction, error)); ok {
		return rf(opts, donIDs, allowed)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []uint32, bool) *types.Transaction); ok {
		r0 = rf(opts, donIDs, allowed)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []uint32, bool) error); ok {
		r1 = rf(opts, donIDs, allowed)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_UpdateAllowedDONs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAllowedDONs'
type WorkflowRegistryInterface_UpdateAllowedDONs_Call struct {
	*mock.Call
}

// UpdateAllowedDONs is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - donIDs []uint32
//   - allowed bool
func (_e *WorkflowRegistryInterface_Expecter) UpdateAllowedDONs(opts interface{}, donIDs interface{}, allowed interface{}) *WorkflowRegistryInterface_UpdateAllowedDONs_Call {
	return &WorkflowRegistryInterface_UpdateAllowedDONs_Call{Call: _e.mock.On("UpdateAllowedDONs", opts, donIDs, allowed)}
}

func (_c *WorkflowRegistryInterface_UpdateAllowedDONs_Call) Run(run func(opts *bind.TransactOpts, donIDs []uint32, allowed bool)) *WorkflowRegistryInterface_UpdateAllowedDONs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]uint32), args[2].(bool))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_UpdateAllowedDONs_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_UpdateAllowedDONs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_UpdateAllowedDONs_Call) RunAndReturn(run func(*bind.TransactOpts, []uint32, bool) (*types.Transaction, error)) *WorkflowRegistryInterface_UpdateAllowedDONs_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAuthorizedAddresses provides a mock function with given fields: opts, addresses, allowed
func (_m *WorkflowRegistryInterface) UpdateAuthorizedAddresses(opts *bind.TransactOpts, addresses []common.Address, allowed bool) (*types.Transaction, error) {
	ret := _m.Called(opts, addresses, allowed)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAuthorizedAddresses")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []common.Address, bool) (*types.Transaction, error)); ok {
		return rf(opts, addresses, allowed)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []common.Address, bool) *types.Transaction); ok {
		r0 = rf(opts, addresses, allowed)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []common.Address, bool) error); ok {
		r1 = rf(opts, addresses, allowed)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_UpdateAuthorizedAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAuthorizedAddresses'
type WorkflowRegistryInterface_UpdateAuthorizedAddresses_Call struct {
	*mock.Call
}

// UpdateAuthorizedAddresses is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - addresses []common.Address
//   - allowed bool
func (_e *WorkflowRegistryInterface_Expecter) UpdateAuthorizedAddresses(opts interface{}, addresses interface{}, allowed interface{}) *WorkflowRegistryInterface_UpdateAuthorizedAddresses_Call {
	return &WorkflowRegistryInterface_UpdateAuthorizedAddresses_Call{Call: _e.mock.On("UpdateAuthorizedAddresses", opts, addresses, allowed)}
}

func (_c *WorkflowRegistryInterface_UpdateAuthorizedAddresses_Call) Run(run func(opts *bind.TransactOpts, addresses []common.Address, allowed bool)) *WorkflowRegistryInterface_UpdateAuthorizedAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]common.Address), args[2].(bool))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_UpdateAuthorizedAddresses_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_UpdateAuthorizedAddresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_UpdateAuthorizedAddresses_Call) RunAndReturn(run func(*bind.TransactOpts, []common.Address, bool) (*types.Transaction, error)) *WorkflowRegistryInterface_UpdateAuthorizedAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorkflow provides a mock function with given fields: opts, workflowKey, newWorkflowID, binaryURL, configURL, secretsURL
func (_m *WorkflowRegistryInterface) UpdateWorkflow(opts *bind.TransactOpts, workflowKey [32]byte, newWorkflowID [32]byte, binaryURL string, configURL string, secretsURL string) (*types.Transaction, error) {
	ret := _m.Called(opts, workflowKey, newWorkflowID, binaryURL, configURL, secretsURL)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorkflow")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, [32]byte, string, string, string) (*types.Transaction, error)); ok {
		return rf(opts, workflowKey, newWorkflowID, binaryURL, configURL, secretsURL)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, [32]byte, string, string, string) *types.Transaction); ok {
		r0 = rf(opts, workflowKey, newWorkflowID, binaryURL, configURL, secretsURL)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte, [32]byte, string, string, string) error); ok {
		r1 = rf(opts, workflowKey, newWorkflowID, binaryURL, configURL, secretsURL)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_UpdateWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorkflow'
type WorkflowRegistryInterface_UpdateWorkflow_Call struct {
	*mock.Call
}

// UpdateWorkflow is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - workflowKey [32]byte
//   - newWorkflowID [32]byte
//   - binaryURL string
//   - configURL string
//   - secretsURL string
func (_e *WorkflowRegistryInterface_Expecter) UpdateWorkflow(opts interface{}, workflowKey interface{}, newWorkflowID interface{}, binaryURL interface{}, configURL interface{}, secretsURL interface{}) *WorkflowRegistryInterface_UpdateWorkflow_Call {
	return &WorkflowRegistryInterface_UpdateWorkflow_Call{Call: _e.mock.On("UpdateWorkflow", opts, workflowKey, newWorkflowID, binaryURL, configURL, secretsURL)}
}

func (_c *WorkflowRegistryInterface_UpdateWorkflow_Call) Run(run func(opts *bind.TransactOpts, workflowKey [32]byte, newWorkflowID [32]byte, binaryURL string, configURL string, secretsURL string)) *WorkflowRegistryInterface_UpdateWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([32]byte), args[2].([32]byte), args[3].(string), args[4].(string), args[5].(string))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_UpdateWorkflow_Call) Return(_a0 *types.Transaction, _a1 error) *WorkflowRegistryInterface_UpdateWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_UpdateWorkflow_Call) RunAndReturn(run func(*bind.TransactOpts, [32]byte, [32]byte, string, string, string) (*types.Transaction, error)) *WorkflowRegistryInterface_UpdateWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// WatchAllowedDONsUpdatedV1 provides a mock function with given fields: opts, sink
func (_m *WorkflowRegistryInterface) WatchAllowedDONsUpdatedV1(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchAllowedDONsUpdatedV1")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchAllowedDONsUpdatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchAllowedDONsUpdatedV1'
type WorkflowRegistryInterface_WatchAllowedDONsUpdatedV1_Call struct {
	*mock.Call
}

// WatchAllowedDONsUpdatedV1 is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1
func (_e *WorkflowRegistryInterface_Expecter) WatchAllowedDONsUpdatedV1(opts interface{}, sink interface{}) *WorkflowRegistryInterface_WatchAllowedDONsUpdatedV1_Call {
	return &WorkflowRegistryInterface_WatchAllowedDONsUpdatedV1_Call{Call: _e.mock.On("WatchAllowedDONsUpdatedV1", opts, sink)}
}

func (_c *WorkflowRegistryInterface_WatchAllowedDONsUpdatedV1_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1)) *WorkflowRegistryInterface_WatchAllowedDONsUpdatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchAllowedDONsUpdatedV1_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchAllowedDONsUpdatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchAllowedDONsUpdatedV1_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryAllowedDONsUpdatedV1) (event.Subscription, error)) *WorkflowRegistryInterface_WatchAllowedDONsUpdatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// WatchAuthorizedAddressesUpdatedV1 provides a mock function with given fields: opts, sink
func (_m *WorkflowRegistryInterface) WatchAuthorizedAddressesUpdatedV1(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchAuthorizedAddressesUpdatedV1")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchAuthorizedAddressesUpdatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchAuthorizedAddressesUpdatedV1'
type WorkflowRegistryInterface_WatchAuthorizedAddressesUpdatedV1_Call struct {
	*mock.Call
}

// WatchAuthorizedAddressesUpdatedV1 is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1
func (_e *WorkflowRegistryInterface_Expecter) WatchAuthorizedAddressesUpdatedV1(opts interface{}, sink interface{}) *WorkflowRegistryInterface_WatchAuthorizedAddressesUpdatedV1_Call {
	return &WorkflowRegistryInterface_WatchAuthorizedAddressesUpdatedV1_Call{Call: _e.mock.On("WatchAuthorizedAddressesUpdatedV1", opts, sink)}
}

func (_c *WorkflowRegistryInterface_WatchAuthorizedAddressesUpdatedV1_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1)) *WorkflowRegistryInterface_WatchAuthorizedAddressesUpdatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchAuthorizedAddressesUpdatedV1_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchAuthorizedAddressesUpdatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchAuthorizedAddressesUpdatedV1_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryAuthorizedAddressesUpdatedV1) (event.Subscription, error)) *WorkflowRegistryInterface_WatchAuthorizedAddressesUpdatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// WatchOwnershipTransferRequested provides a mock function with given fields: opts, sink, from, to
func (_m *WorkflowRegistryInterface) WatchOwnershipTransferRequested(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested, from []common.Address, to []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, from, to)

	if len(ret) == 0 {
		panic("no return value specified for WatchOwnershipTransferRequested")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchOwnershipTransferRequested_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchOwnershipTransferRequested'
type WorkflowRegistryInterface_WatchOwnershipTransferRequested_Call struct {
	*mock.Call
}

// WatchOwnershipTransferRequested is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested
//   - from []common.Address
//   - to []common.Address
func (_e *WorkflowRegistryInterface_Expecter) WatchOwnershipTransferRequested(opts interface{}, sink interface{}, from interface{}, to interface{}) *WorkflowRegistryInterface_WatchOwnershipTransferRequested_Call {
	return &WorkflowRegistryInterface_WatchOwnershipTransferRequested_Call{Call: _e.mock.On("WatchOwnershipTransferRequested", opts, sink, from, to)}
}

func (_c *WorkflowRegistryInterface_WatchOwnershipTransferRequested_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested, from []common.Address, to []common.Address)) *WorkflowRegistryInterface_WatchOwnershipTransferRequested_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested), args[2].([]common.Address), args[3].([]common.Address))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchOwnershipTransferRequested_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchOwnershipTransferRequested_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchOwnershipTransferRequested_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferRequested, []common.Address, []common.Address) (event.Subscription, error)) *WorkflowRegistryInterface_WatchOwnershipTransferRequested_Call {
	_c.Call.Return(run)
	return _c
}

// WatchOwnershipTransferred provides a mock function with given fields: opts, sink, from, to
func (_m *WorkflowRegistryInterface) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred, from []common.Address, to []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, from, to)

	if len(ret) == 0 {
		panic("no return value specified for WatchOwnershipTransferred")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchOwnershipTransferred_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchOwnershipTransferred'
type WorkflowRegistryInterface_WatchOwnershipTransferred_Call struct {
	*mock.Call
}

// WatchOwnershipTransferred is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred
//   - from []common.Address
//   - to []common.Address
func (_e *WorkflowRegistryInterface_Expecter) WatchOwnershipTransferred(opts interface{}, sink interface{}, from interface{}, to interface{}) *WorkflowRegistryInterface_WatchOwnershipTransferred_Call {
	return &WorkflowRegistryInterface_WatchOwnershipTransferred_Call{Call: _e.mock.On("WatchOwnershipTransferred", opts, sink, from, to)}
}

func (_c *WorkflowRegistryInterface_WatchOwnershipTransferred_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred, from []common.Address, to []common.Address)) *WorkflowRegistryInterface_WatchOwnershipTransferred_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred), args[2].([]common.Address), args[3].([]common.Address))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchOwnershipTransferred_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchOwnershipTransferred_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchOwnershipTransferred_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryOwnershipTransferred, []common.Address, []common.Address) (event.Subscription, error)) *WorkflowRegistryInterface_WatchOwnershipTransferred_Call {
	_c.Call.Return(run)
	return _c
}

// WatchRegistryLockedV1 provides a mock function with given fields: opts, sink
func (_m *WorkflowRegistryInterface) WatchRegistryLockedV1(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchRegistryLockedV1")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchRegistryLockedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchRegistryLockedV1'
type WorkflowRegistryInterface_WatchRegistryLockedV1_Call struct {
	*mock.Call
}

// WatchRegistryLockedV1 is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1
func (_e *WorkflowRegistryInterface_Expecter) WatchRegistryLockedV1(opts interface{}, sink interface{}) *WorkflowRegistryInterface_WatchRegistryLockedV1_Call {
	return &WorkflowRegistryInterface_WatchRegistryLockedV1_Call{Call: _e.mock.On("WatchRegistryLockedV1", opts, sink)}
}

func (_c *WorkflowRegistryInterface_WatchRegistryLockedV1_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1)) *WorkflowRegistryInterface_WatchRegistryLockedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchRegistryLockedV1_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchRegistryLockedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchRegistryLockedV1_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryLockedV1) (event.Subscription, error)) *WorkflowRegistryInterface_WatchRegistryLockedV1_Call {
	_c.Call.Return(run)
	return _c
}

// WatchRegistryUnlockedV1 provides a mock function with given fields: opts, sink
func (_m *WorkflowRegistryInterface) WatchRegistryUnlockedV1(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchRegistryUnlockedV1")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchRegistryUnlockedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchRegistryUnlockedV1'
type WorkflowRegistryInterface_WatchRegistryUnlockedV1_Call struct {
	*mock.Call
}

// WatchRegistryUnlockedV1 is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1
func (_e *WorkflowRegistryInterface_Expecter) WatchRegistryUnlockedV1(opts interface{}, sink interface{}) *WorkflowRegistryInterface_WatchRegistryUnlockedV1_Call {
	return &WorkflowRegistryInterface_WatchRegistryUnlockedV1_Call{Call: _e.mock.On("WatchRegistryUnlockedV1", opts, sink)}
}

func (_c *WorkflowRegistryInterface_WatchRegistryUnlockedV1_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1)) *WorkflowRegistryInterface_WatchRegistryUnlockedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchRegistryUnlockedV1_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchRegistryUnlockedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchRegistryUnlockedV1_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryRegistryUnlockedV1) (event.Subscription, error)) *WorkflowRegistryInterface_WatchRegistryUnlockedV1_Call {
	_c.Call.Return(run)
	return _c
}

// WatchWorkflowActivatedV1 provides a mock function with given fields: opts, sink, workflowID, workflowOwner, donID
func (_m *WorkflowRegistryInterface) WatchWorkflowActivatedV1(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, workflowID, workflowOwner, donID)

	if len(ret) == 0 {
		panic("no return value specified for WatchWorkflowActivatedV1")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1, [][32]byte, []common.Address, []uint32) (event.Subscription, error)); ok {
		return rf(opts, sink, workflowID, workflowOwner, donID)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1, [][32]byte, []common.Address, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, workflowID, workflowOwner, donID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1, [][32]byte, []common.Address, []uint32) error); ok {
		r1 = rf(opts, sink, workflowID, workflowOwner, donID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchWorkflowActivatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchWorkflowActivatedV1'
type WorkflowRegistryInterface_WatchWorkflowActivatedV1_Call struct {
	*mock.Call
}

// WatchWorkflowActivatedV1 is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1
//   - workflowID [][32]byte
//   - workflowOwner []common.Address
//   - donID []uint32
func (_e *WorkflowRegistryInterface_Expecter) WatchWorkflowActivatedV1(opts interface{}, sink interface{}, workflowID interface{}, workflowOwner interface{}, donID interface{}) *WorkflowRegistryInterface_WatchWorkflowActivatedV1_Call {
	return &WorkflowRegistryInterface_WatchWorkflowActivatedV1_Call{Call: _e.mock.On("WatchWorkflowActivatedV1", opts, sink, workflowID, workflowOwner, donID)}
}

func (_c *WorkflowRegistryInterface_WatchWorkflowActivatedV1_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32)) *WorkflowRegistryInterface_WatchWorkflowActivatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1), args[2].([][32]byte), args[3].([]common.Address), args[4].([]uint32))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowActivatedV1_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchWorkflowActivatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowActivatedV1_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowActivatedV1, [][32]byte, []common.Address, []uint32) (event.Subscription, error)) *WorkflowRegistryInterface_WatchWorkflowActivatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// WatchWorkflowDeletedV1 provides a mock function with given fields: opts, sink, workflowID, workflowOwner, donID
func (_m *WorkflowRegistryInterface) WatchWorkflowDeletedV1(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, workflowID, workflowOwner, donID)

	if len(ret) == 0 {
		panic("no return value specified for WatchWorkflowDeletedV1")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1, [][32]byte, []common.Address, []uint32) (event.Subscription, error)); ok {
		return rf(opts, sink, workflowID, workflowOwner, donID)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1, [][32]byte, []common.Address, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, workflowID, workflowOwner, donID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1, [][32]byte, []common.Address, []uint32) error); ok {
		r1 = rf(opts, sink, workflowID, workflowOwner, donID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchWorkflowDeletedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchWorkflowDeletedV1'
type WorkflowRegistryInterface_WatchWorkflowDeletedV1_Call struct {
	*mock.Call
}

// WatchWorkflowDeletedV1 is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1
//   - workflowID [][32]byte
//   - workflowOwner []common.Address
//   - donID []uint32
func (_e *WorkflowRegistryInterface_Expecter) WatchWorkflowDeletedV1(opts interface{}, sink interface{}, workflowID interface{}, workflowOwner interface{}, donID interface{}) *WorkflowRegistryInterface_WatchWorkflowDeletedV1_Call {
	return &WorkflowRegistryInterface_WatchWorkflowDeletedV1_Call{Call: _e.mock.On("WatchWorkflowDeletedV1", opts, sink, workflowID, workflowOwner, donID)}
}

func (_c *WorkflowRegistryInterface_WatchWorkflowDeletedV1_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32)) *WorkflowRegistryInterface_WatchWorkflowDeletedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1), args[2].([][32]byte), args[3].([]common.Address), args[4].([]uint32))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowDeletedV1_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchWorkflowDeletedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowDeletedV1_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowDeletedV1, [][32]byte, []common.Address, []uint32) (event.Subscription, error)) *WorkflowRegistryInterface_WatchWorkflowDeletedV1_Call {
	_c.Call.Return(run)
	return _c
}

// WatchWorkflowForceUpdateSecretsRequestedV1 provides a mock function with given fields: opts, sink, owner
func (_m *WorkflowRegistryInterface) WatchWorkflowForceUpdateSecretsRequestedV1(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1, owner []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, owner)

	if len(ret) == 0 {
		panic("no return value specified for WatchWorkflowForceUpdateSecretsRequestedV1")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, owner)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, owner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1, []common.Address) error); ok {
		r1 = rf(opts, sink, owner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchWorkflowForceUpdateSecretsRequestedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchWorkflowForceUpdateSecretsRequestedV1'
type WorkflowRegistryInterface_WatchWorkflowForceUpdateSecretsRequestedV1_Call struct {
	*mock.Call
}

// WatchWorkflowForceUpdateSecretsRequestedV1 is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1
//   - owner []common.Address
func (_e *WorkflowRegistryInterface_Expecter) WatchWorkflowForceUpdateSecretsRequestedV1(opts interface{}, sink interface{}, owner interface{}) *WorkflowRegistryInterface_WatchWorkflowForceUpdateSecretsRequestedV1_Call {
	return &WorkflowRegistryInterface_WatchWorkflowForceUpdateSecretsRequestedV1_Call{Call: _e.mock.On("WatchWorkflowForceUpdateSecretsRequestedV1", opts, sink, owner)}
}

func (_c *WorkflowRegistryInterface_WatchWorkflowForceUpdateSecretsRequestedV1_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1, owner []common.Address)) *WorkflowRegistryInterface_WatchWorkflowForceUpdateSecretsRequestedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1), args[2].([]common.Address))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowForceUpdateSecretsRequestedV1_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchWorkflowForceUpdateSecretsRequestedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowForceUpdateSecretsRequestedV1_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowForceUpdateSecretsRequestedV1, []common.Address) (event.Subscription, error)) *WorkflowRegistryInterface_WatchWorkflowForceUpdateSecretsRequestedV1_Call {
	_c.Call.Return(run)
	return _c
}

// WatchWorkflowPausedV1 provides a mock function with given fields: opts, sink, workflowID, workflowOwner, donID
func (_m *WorkflowRegistryInterface) WatchWorkflowPausedV1(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, workflowID, workflowOwner, donID)

	if len(ret) == 0 {
		panic("no return value specified for WatchWorkflowPausedV1")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1, [][32]byte, []common.Address, []uint32) (event.Subscription, error)); ok {
		return rf(opts, sink, workflowID, workflowOwner, donID)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1, [][32]byte, []common.Address, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, workflowID, workflowOwner, donID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1, [][32]byte, []common.Address, []uint32) error); ok {
		r1 = rf(opts, sink, workflowID, workflowOwner, donID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchWorkflowPausedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchWorkflowPausedV1'
type WorkflowRegistryInterface_WatchWorkflowPausedV1_Call struct {
	*mock.Call
}

// WatchWorkflowPausedV1 is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1
//   - workflowID [][32]byte
//   - workflowOwner []common.Address
//   - donID []uint32
func (_e *WorkflowRegistryInterface_Expecter) WatchWorkflowPausedV1(opts interface{}, sink interface{}, workflowID interface{}, workflowOwner interface{}, donID interface{}) *WorkflowRegistryInterface_WatchWorkflowPausedV1_Call {
	return &WorkflowRegistryInterface_WatchWorkflowPausedV1_Call{Call: _e.mock.On("WatchWorkflowPausedV1", opts, sink, workflowID, workflowOwner, donID)}
}

func (_c *WorkflowRegistryInterface_WatchWorkflowPausedV1_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32)) *WorkflowRegistryInterface_WatchWorkflowPausedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1), args[2].([][32]byte), args[3].([]common.Address), args[4].([]uint32))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowPausedV1_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchWorkflowPausedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowPausedV1_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowPausedV1, [][32]byte, []common.Address, []uint32) (event.Subscription, error)) *WorkflowRegistryInterface_WatchWorkflowPausedV1_Call {
	_c.Call.Return(run)
	return _c
}

// WatchWorkflowRegisteredV1 provides a mock function with given fields: opts, sink, workflowID, workflowOwner, donID
func (_m *WorkflowRegistryInterface) WatchWorkflowRegisteredV1(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, workflowID, workflowOwner, donID)

	if len(ret) == 0 {
		panic("no return value specified for WatchWorkflowRegisteredV1")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1, [][32]byte, []common.Address, []uint32) (event.Subscription, error)); ok {
		return rf(opts, sink, workflowID, workflowOwner, donID)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1, [][32]byte, []common.Address, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, workflowID, workflowOwner, donID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1, [][32]byte, []common.Address, []uint32) error); ok {
		r1 = rf(opts, sink, workflowID, workflowOwner, donID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchWorkflowRegisteredV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchWorkflowRegisteredV1'
type WorkflowRegistryInterface_WatchWorkflowRegisteredV1_Call struct {
	*mock.Call
}

// WatchWorkflowRegisteredV1 is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1
//   - workflowID [][32]byte
//   - workflowOwner []common.Address
//   - donID []uint32
func (_e *WorkflowRegistryInterface_Expecter) WatchWorkflowRegisteredV1(opts interface{}, sink interface{}, workflowID interface{}, workflowOwner interface{}, donID interface{}) *WorkflowRegistryInterface_WatchWorkflowRegisteredV1_Call {
	return &WorkflowRegistryInterface_WatchWorkflowRegisteredV1_Call{Call: _e.mock.On("WatchWorkflowRegisteredV1", opts, sink, workflowID, workflowOwner, donID)}
}

func (_c *WorkflowRegistryInterface_WatchWorkflowRegisteredV1_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1, workflowID [][32]byte, workflowOwner []common.Address, donID []uint32)) *WorkflowRegistryInterface_WatchWorkflowRegisteredV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1), args[2].([][32]byte), args[3].([]common.Address), args[4].([]uint32))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowRegisteredV1_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchWorkflowRegisteredV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowRegisteredV1_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowRegisteredV1, [][32]byte, []common.Address, []uint32) (event.Subscription, error)) *WorkflowRegistryInterface_WatchWorkflowRegisteredV1_Call {
	_c.Call.Return(run)
	return _c
}

// WatchWorkflowUpdatedV1 provides a mock function with given fields: opts, sink, oldWorkflowID, workflowOwner, donID
func (_m *WorkflowRegistryInterface) WatchWorkflowUpdatedV1(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1, oldWorkflowID [][32]byte, workflowOwner []common.Address, donID []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, oldWorkflowID, workflowOwner, donID)

	if len(ret) == 0 {
		panic("no return value specified for WatchWorkflowUpdatedV1")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1, [][32]byte, []common.Address, []uint32) (event.Subscription, error)); ok {
		return rf(opts, sink, oldWorkflowID, workflowOwner, donID)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1, [][32]byte, []common.Address, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, oldWorkflowID, workflowOwner, donID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1, [][32]byte, []common.Address, []uint32) error); ok {
		r1 = rf(opts, sink, oldWorkflowID, workflowOwner, donID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkflowRegistryInterface_WatchWorkflowUpdatedV1_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchWorkflowUpdatedV1'
type WorkflowRegistryInterface_WatchWorkflowUpdatedV1_Call struct {
	*mock.Call
}

// WatchWorkflowUpdatedV1 is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1
//   - oldWorkflowID [][32]byte
//   - workflowOwner []common.Address
//   - donID []uint32
func (_e *WorkflowRegistryInterface_Expecter) WatchWorkflowUpdatedV1(opts interface{}, sink interface{}, oldWorkflowID interface{}, workflowOwner interface{}, donID interface{}) *WorkflowRegistryInterface_WatchWorkflowUpdatedV1_Call {
	return &WorkflowRegistryInterface_WatchWorkflowUpdatedV1_Call{Call: _e.mock.On("WatchWorkflowUpdatedV1", opts, sink, oldWorkflowID, workflowOwner, donID)}
}

func (_c *WorkflowRegistryInterface_WatchWorkflowUpdatedV1_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1, oldWorkflowID [][32]byte, workflowOwner []common.Address, donID []uint32)) *WorkflowRegistryInterface_WatchWorkflowUpdatedV1_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1), args[2].([][32]byte), args[3].([]common.Address), args[4].([]uint32))
	})
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowUpdatedV1_Call) Return(_a0 event.Subscription, _a1 error) *WorkflowRegistryInterface_WatchWorkflowUpdatedV1_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *WorkflowRegistryInterface_WatchWorkflowUpdatedV1_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *workflow_registry_wrapper.WorkflowRegistryWorkflowUpdatedV1, [][32]byte, []common.Address, []uint32) (event.Subscription, error)) *WorkflowRegistryInterface_WatchWorkflowUpdatedV1_Call {
	_c.Call.Return(run)
	return _c
}

// NewWorkflowRegistryInterface creates a new instance of WorkflowRegistryInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWorkflowRegistryInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *WorkflowRegistryInterface {
	mock := &WorkflowRegistryInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
